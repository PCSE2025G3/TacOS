/*
 * TacOS Source Code
 *    Tokuyama kousen Advanced educational Computer.
 *
 * Copyright (C) 2020 by
 *                      Dept. of Computer Science and Electronic Engineering,
 *                      Tokuyama College of Technology, JAPAN
 *
 *   上記著作権者は，Free Software Foundation によって公開されている GNU 一般公
 * 衆利用許諾契約書バージョン２に記述されている条件を満たす場合に限り，本ソース
 * コード(本ソースコードを改変したものを含む．以下同様)を使用・複製・改変・再配
 * 布することを無償で許諾する．
 *
 *   本ソースコードは＊全くの無保証＊で提供されるものである。上記著作権者および
 * 関連機関・個人は本ソースコードに関して，その適用可能性も含めて，いかなる保証
 * も行わない．また，本ソースコードの利用により直接的または間接的に生じたいかな
 * る損害に関しても，その責任を負わない．
 *
 *
 */

/*
 * shellProc.cmm : MP3 プレーヤのメインプロセス
 *
 * 2020.09.07 : 新規作成
 *
 * $Id$
 *
 */
#include <kernel.hmm> //使用するヘッダー宣言
#include <util.hmm>
#include "appUtil.hmm"
#include "lcd.hmm"
#include "mp3Proc.hmm"
#include "spi.hmm"
#include "mp3Files.hmm"
#include "shellProc.hmm"
#include "screenState.hmm"
#include "mm.hmm"
#include "option.hmm"
#include "playList.hmm"


//-----------------------------------------------------------------------------
// スイッチの読み取り
//-----------------------------------------------------------------------------
// 押しボタンスイッチのビット
#define SW1 0x20
#define SW2 0x10
#define SW3 0x08
#define SW4 0x04
#define SW5 0x02
#define SW6 0x01
#define SWS 0x3f                                    // スイッチのビット全部

//------------------------------------------------------------------------------------------------------------------------------------------------
//画面ごとの番号定義 0:ホーム　1：曲一覧　2：再生画面　3：オプション　4：音量調整　5：コントラスト調整　6.プレイリスト　7.プレイリストの登録曲表示
//------------------------------------------------------------------------------------------------------------------------------------------------
#define HOME_STATE 0
#define MUSIC_STATE 1
#define MUSIC_INF 2
#define OPTION_STATE 3
#define VOLUME_STATE 4
#define CONTRAST_STATE 5
#define PLAYLIST_STATE 6
#define PLAYLIST_SONGS 7
//------------------------------------------------------------------------------------------------------------------------------------------------

#define MAX_LIST 6
#define NAME_LEN 16

char[][] musicList;
char[][] playList;
char[][] playList_register;
int[] prevcursor = array(15);                       // カーソル情報を保持する変数

int sw0 = 0x00;                                     // 前回の状態(デバウンス前)
int sw1 = 0x00;                                     // 前回の状態(デバウンス後)

int readSw() {
  int sw = ~in(0x18) & SWS;                         // スイッチを読み正論理に変換
  int swd = sw & sw0;                               // デバウンス
  int sw2 = (sw1 ^ swd) & swd;                      // 今回，新たに押されたSW
  sw0 = sw;
  sw1 = swd;
  return sw2;
}

int swToNum(int sw) {
  int num = -1;
  if ((sw & SW6)!=0) {                              // 6 番のスイッチが押された
    num = 6;
  } else if ((sw & SW5)!=0) {                       // 5 番のスイッチが押された
    num = 5;
  } else if ((sw & SW4)!=0) {                       // 4 番のスイッチが押された
    num = 4;
  } else if ((sw & SW3)!=0) {                       // 3 番のスイッチが押された
    num = 3;
  } else if ((sw & SW2)!=0) {                       // 2 番のスイッチが押された
    num = 2;
  } else if ((sw & SW1)!=0) {                       // 1 番のスイッチが押された
    num = 1;
  }
  return num;
}

//画面を表示する関数
void showScreen(int state, int cursorPos) {
    cls();
    locateXY(0, 0);
    putStr(getScreenTitle(state));

    int numItems = getScreenNumItems(state);
    char[][] menuItems = getScreenMenuItems(state);

    for (int i = 0; i < numItems; i=i+1) {
        locateXY(1, i + 1);

        if (i == cursorPos) {
            putStr("-> ");
        } else {
            putStr("   ");
        }

        putStr(menuItems[i]);
    }
    if (state == CONTRAST_STATE) {
      showLevelBar(getContrastLevel());
    }
    else if (state == VOLUME_STATE) {
      showLevelBar(getVolumeLevel());
    }
  }
//-----------------------------------------
//曲一覧用のメモリ確保
//-----------------------------------------
void malloc_musiclist(int upper_idx){
  musicList = malloc(MAX_LIST * 4);
    int i = 0;
    while (i < MAX_LIST) {
      musicList[i] = malloc(NAME_LEN);
      char[] fname = mp3FilesGetName(i + upper_idx + 1);
      if (fname != null) {
        strCpy(musicList[i], fname);
      } else {
        musicList[i][0] = '\0';
      }
      i = i + 1;
    }
}

//-----------------------------------------
//曲一覧用のメモリ解放
//-----------------------------------------
void free_musiclist(){
  int i = 0;
    while (i < MAX_LIST) {
      free(musicList[i]);
      i = i + 1;
    }
    free(musicList);
}

//-----------------------------------------
//プレイリスト(list01~10)一覧用のメモリ確保
//-----------------------------------------
void malloc_playlist(int upper_idx){
  playList = malloc(MAX_LIST * 4);
    int i = 0;
    while (i < MAX_LIST) {
      playList[i] = malloc(NAME_LEN);
      char[] fname = playListGetName(i + upper_idx + 1);
      if (fname != null) {
        strCpy(playList[i], fname);
      } else {
        playList[i][0] = '\0';
      }
      i = i + 1;
    }
}

//-----------------------------------------
//プレイリスト(list01~list10)一覧用のメモリ解放
//-----------------------------------------
void free_playlist(){
  int i = 0;
    while (i < MAX_LIST) {
      free(playList[i]);
      i = i + 1;
    }
    free(playList);
}

//-----------------------------------------
//プレイリスト登録曲のメモリ確保
//-----------------------------------------
void malloc_playlist_register(int list_idx){
  playList_register = malloc(MAX_LIST * 4);
    int i = 0;
    while (i < MAX_LIST) {
      playList_register[i] = malloc(NAME_LEN);
      char[] fname = playListSongsGetName(list_idx, i + 1);
      if (fname != null) {
        strCpy(playList_register[i], fname);
      } else {
        playList_register[i][0] = '\0';
      }
      i = i + 1;
    }
}

//-----------------------------------------
//プレイリスト登録曲のメモリ解放
//-----------------------------------------
void free_playlist_register(){
  int i = 0;
    while (i < MAX_LIST) {
      free(playList_register[i]);
      i = i + 1;
    }
    free(playList_register);
}



//-----------------------------------------------------------------------------
// MP3 プレーヤのメインプロセス
//-----------------------------------------------------------------------------
// ここからプロセスの実行が始まる
public void shellMain() {
  spiResetLcd();  // sleepを使用するので
  cls();
  spiResetMp3();  //   プロセスが実行する
  mp3FilesInit();  // ファイル一覧を作る
  playListInit(); // プレイリストの一覧を作る
  initScreens();

  int state = HOME_STATE;
  int prevState = HOME_STATE;  // OPTION用：前の状態を記憶
  int cursorPos = 0;
  int music_idx = 0;
  int total = 0;
  int list_upper = 0; //リスト表示される要素の最上のインデクスを保持する．
  int listNum = 0; //選択されたプレイリスト番号を保持する．

  showScreen(state, cursorPos);

  //メインプロセスのループ
  for (;;) {
    int sw = readSw();
    int num = swToNum(sw);
    int filenum = mp3FilesGetTotalNum(); //MP3ファイルの総数

    if (num == 1) {  // SW1 = 上
      int numItems = getScreenNumItems(state);

      // カーソルがまだ上に動かせる
      if (cursorPos > 0) {
        cursorPos = cursorPos - 1;
      } else if (state == MUSIC_STATE) {
        //曲選択画面で，かつ上端まで来たときの処理
        if (cursorPos == 0 && list_upper > 0) {
          list_upper = list_upper - 1;
          free_musiclist();
          malloc_musiclist(list_upper);
          setScreenMenuItems(state, musicList, MAX_LIST);
        }
      } else if (state == PLAYLIST_STATE){
        //プレイリスト画面で，かつ上端まで来たときの処理
        if (cursorPos == 0 && list_upper > 0) {
          list_upper = list_upper - 1;
          free_playlist();
          malloc_playlist(list_upper);
          setScreenMenuItems(state, playList, MAX_LIST);
        }
      }else {
        // 項目数が6以下のとき：ループ処理
        cursorPos = numItems - 1;
        }
        prevcursor[state] = cursorPos; //カーソル情報の保持
        showScreen(state, cursorPos);
    }
    else if (num == 5) {  // SW5 = 下
      int numItems = getScreenNumItems(state);

      // カーソルがまだ下に動かせる
      if (cursorPos + 1 < numItems) {
        cursorPos = cursorPos + 1;
      } else if (state == MUSIC_STATE) {
        //曲選択画面で，かつ下端まで来たときの処理
        if (cursorPos + list_upper < filenum - 1) {
          list_upper = list_upper + 1;
          free_musiclist();
          malloc_musiclist(list_upper);
          setScreenMenuItems(state, musicList, MAX_LIST);
        }
      }  else if (state == PLAYLIST_STATE) {
        //プレイリスト画面で，かつ下端まで来たときのスクロール処理
        if (cursorPos + list_upper < 9) {
          list_upper = list_upper + 1;
          free_playlist();
          malloc_playlist(list_upper);
          setScreenMenuItems(state, playList, MAX_LIST);
        }
      } else {
        //下端→上端ループ
        cursorPos = 0;
        list_upper = 0;
      }
      prevcursor[state] = cursorPos;
      showScreen(state, cursorPos);
    }

    else if (num == 3) { // SW3 = 決定
      if (state == HOME_STATE) {
        //musicを押した場合
        if (cursorPos + 1 == 1) {
          mp3FilesInit();                                         // playList で格納した fnames の影響を解消するため
          malloc_musiclist(list_upper);
          setScreenMenuItems(MUSIC_STATE, musicList, MAX_LIST);
          prevState = state;
          state = MUSIC_STATE;
          cursorPos = 0;
          showScreen(state, cursorPos);
        } else {
          //PlayListを押した場合
          cursorPos=0;
          list_upper = 0;
          prevState = state;
          state = PLAYLIST_STATE;
          int numlist = getScreenNumItems(state);
          malloc_playlist(list_upper);
          setScreenMenuItems(state, playList, numlist);
          showScreen(state, cursorPos);
        }
      }
      else if (state == MUSIC_STATE) {
        char[] selectedTitle = malloc(NAME_LEN);
        music_idx = cursorPos + list_upper +1;
        char[] fname = mp3FilesGetName(music_idx);
        
        if (fname != null) {
          strCpy(selectedTitle, fname);
          setScreenTitle(MUSIC_INF, selectedTitle);
          prevState = state;
          state = MUSIC_INF;
          cursorPos = 0;
          showScreen(state, cursorPos);
        }
      }
      else if (state == MUSIC_INF) {
        if (cursorPos == 0) {  // PLAY 選択
          char[] path = mp3FilesGetPath(music_idx);  // 曲パス取得
          if (path != null) play(path);
        }
        else if (cursorPos == 1) {  // PAUSE 選択
          stop();
        }
        else if (cursorPos == 2) { //NEXT選択時
        int status = playing_status();
          stop();
          total = mp3FilesGetTotalNum();
          music_idx = (music_idx % total) + 1;
          char[] nextTitle = mp3FilesGetName(music_idx);
          if (nextTitle != null) {
            setScreenTitle(MUSIC_INF, nextTitle);
            showScreen(state, cursorPos);
            char[] path = mp3FilesGetPath(music_idx);
            if (status == 1) {
              play(path);
            }
          }
        }
        else if (cursorPos == 3) {  // PREV 選択
          int status = playing_status();
          stop();
          total = mp3FilesGetTotalNum();
          music_idx = (music_idx + total - 2) % total + 1;
          char[] prevTitle = mp3FilesGetName(music_idx);
          if (prevTitle != null) {
            setScreenTitle(MUSIC_INF, prevTitle);
            showScreen(state, cursorPos);
            char[] path = mp3FilesGetPath(music_idx);
            if (status == 1) {
              play(path);
            }
          }
        }
      }
      else if (state == OPTION_STATE) {
        if (cursorPos == 0) {  // VOLUME
          state = VOLUME_STATE;
          cursorPos = 0;
          showScreen(state, cursorPos);
        }
        else if (cursorPos == 1) {  // CONTRAST
          state = CONTRAST_STATE;
          cursorPos = 0;
          showScreen(state, cursorPos);
        }
      }
      else if (state == VOLUME_STATE) {
        if (cursorPos == 0) {
          updateVolume(cursorPos);
          showScreen(state, cursorPos);
        } else if (cursorPos == 1) {
          updateVolume(cursorPos);
          showScreen(state, cursorPos);
        }
      }
      else if (state == CONTRAST_STATE) {
        if (cursorPos == 0) {  // UP
          updateContrast(cursorPos);
          showScreen(state, cursorPos);
        } else if (cursorPos == 1) {  // DOWN
          updateContrast(cursorPos);
          showScreen(state, cursorPos);
        }
      }
      else if (state == PLAYLIST_STATE) {
        listNum = cursorPos +  list_upper + 1;
        showPlayListSongs(listNum);
        int songNum;
        if (playListSongsGetNum(listNum) <= MAX_LIST) {
          songNum = playListSongsGetNum(listNum);
        } else {
          songNum = MAX_LIST;
        }
        malloc_playlist_register(listNum);
        prevState = state;
        state = PLAYLIST_SONGS;
        setScreenMenuItems(state, playList_register, songNum);
        cursorPos = 0;
        showScreen(state, cursorPos);
      }
      else if (state == PLAYLIST_SONGS) {
        if (strCmp(playListSongsGetName(listNum, cursorPos + list_upper + 1), "+") == 0) {
          // いまのカーソル位置（cursorPos + list_upper）が "+"なら曲を追加する
        }
        else {
          // 選択された曲を再生する
          mp3FilesSetToFnames(playListSongsNametoMp3Files()); //mp3Files の fnames にプレイリストの曲を格納する
          char[] selectedTitle = malloc(NAME_LEN);
          music_idx = cursorPos + list_upper + 1;
          char[] fname = playListSongsGetName(listNum, music_idx);
          
          if (fname != null) {
            strCpy(selectedTitle, fname);
            setScreenTitle(MUSIC_INF, selectedTitle);
            prevState = state;
            state = MUSIC_INF;
            cursorPos = 0;
            showScreen(state, cursorPos);
          }

        }
      }
    }

    else if (num == 2) { // SW2 = 戻る
      if (state == MUSIC_STATE) {
        free_musiclist();
        state = HOME_STATE;
        cursorPos = prevcursor[state];
        showScreen(state, cursorPos);
      }
      else if (state == MUSIC_INF) {
        if (prevState == MUSIC_STATE) {
          state = MUSIC_STATE;
        } else {
          state = PLAYLIST_SONGS;
        }
        cursorPos = prevcursor[state];
        showScreen(state, cursorPos);
      }
      else if (state == VOLUME_STATE) {
        state = OPTION_STATE;
        cursorPos = prevcursor[state];
        showScreen(state, cursorPos);
      }
      else if (state == CONTRAST_STATE) {
        state = OPTION_STATE;
        cursorPos = prevcursor[state];
        showScreen(state, cursorPos);
      }
      else if (state == PLAYLIST_STATE) {
        free_playlist();
        state = HOME_STATE;
        cursorPos = prevcursor[state];
        showScreen(state, cursorPos);
      }
      else if (state == PLAYLIST_SONGS) {
        free_playlist_register();
        state = PLAYLIST_STATE;
        cursorPos = prevcursor[state];
        showScreen(state, cursorPos);
      }
    }

    else if (num == 6) { // SW6 = OPTION 画面の出入り
      if (state == VOLUME_STATE || state == CONTRAST_STATE) {
        state = prevState;
        cursorPos = prevcursor[state];
        showScreen(state, cursorPos);
      }
      else if (state == OPTION_STATE) {
        state = prevState;      // OPTIONに入る前の状態を記録
        cursorPos = prevcursor[state];
        showScreen(state, cursorPos); 
      } else { //OPTION画面に入る．
        prevState = state;
        state = OPTION_STATE;
        cursorPos = 0;
        showScreen(state, cursorPos);
      }
    }
   
    sleep(10);  // 負荷軽減，10ms待つ
  }
}
