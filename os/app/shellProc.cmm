/*
 * TacOS Source Code
 *    Tokuyama kousen Advanced educational Computer.
 *
 * Copyright (C) 2020 by
 *                      Dept. of Computer Science and Electronic Engineering,
 *                      Tokuyama College of Technology, JAPAN
 *
 *   上記著作権者は，Free Software Foundation によって公開されている GNU 一般公
 * 衆利用許諾契約書バージョン２に記述されている条件を満たす場合に限り，本ソース
 * コード(本ソースコードを改変したものを含む．以下同様)を使用・複製・改変・再配
 * 布することを無償で許諾する．
 *
 *   本ソースコードは＊全くの無保証＊で提供されるものである。上記著作権者および
 * 関連機関・個人は本ソースコードに関して，その適用可能性も含めて，いかなる保証
 * も行わない．また，本ソースコードの利用により直接的または間接的に生じたいかな
 * る損害に関しても，その責任を負わない．
 *
 *
 */

/*
 * shellProc.cmm : MP3 プレーヤのメインプロセス
 *
 * 2020.09.07 : 新規作成
 *
 * $Id$
 *
 */
#include <kernel.hmm> //使用するヘッダー宣言
#include <util.hmm>
#include "appUtil.hmm"
#include "lcd.hmm"
#include "mp3Proc.hmm"
#include "spi.hmm"
#include "mp3Files.hmm"
#include "shellProc.hmm"
#include "screenState.hmm"
#include "mm.hmm"
#include "option.hmm"
#include "playList.hmm"
#include <stdlib.hmm>


//-----------------------------------------------------------------------------
// スイッチの読み取り
//-----------------------------------------------------------------------------
// 押しボタンスイッチのビット
#define SW1 0x20
#define SW2 0x10
#define SW3 0x08
#define SW4 0x04
#define SW5 0x02
#define SW6 0x01
#define SWS 0x3f                                    // スイッチのビット全部

//------------------------------------------------------------------------------------------------------------------------------------------------
//画面ごとの番号定義 0:ホーム　1：曲一覧　2：再生画面　3：オプション　4：音量調整　5：コントラスト調整　6.プレイリスト　7.プレイリストの登録曲表示　8.プレイリストの曲追加
//------------------------------------------------------------------------------------------------------------------------------------------------
#define HOME_STATE 0
#define MUSIC_STATE 1
#define MUSIC_INF 2
#define OPTION_STATE 3
#define VOLUME_STATE 4
#define CONTRAST_STATE 5
#define PLAYLIST_STATE 6
#define PLAYLIST_SONGS 7
#define PLAYLIST_ADDSONGS 8
//------------------------------------------------------------------------------------------------------------------------------------------------

#define MAX_LIST 6
#define NAME_LEN 16

char[][] musicList;
char[][] playList;
char[][] playList_register;
char[][] playList_add;
int[] prevcursor = array(15);                       // カーソル情報を保持する変数
int[] prevupper = array(15);                        // 画面最上のインデクスを保持する変数
int[] addSongsIdx = array(50);

int sw0 = 0x00;                                     // 前回の状態(デバウンス前)
int sw1 = 0x00;
int isPlayRequested = 0;                            // PLAYが選ばれたら1、PAUSEなら0
int repeatMode = 0;                                 //リピート管理変数
int shuffleMode = 0;                                //シャッフル管理関数
int [] shuffleList;                                 //シャッフルリスト
int shuffleIndex = 0;                               //シャッフル再生中のインデックス
int list_upper = 0;

int readSw() {
  int sw = ~in(0x18) & SWS;                         // スイッチを読み正論理に変換
  int swd = sw & sw0;                               // デバウンス
  int sw2 = (sw1 ^ swd) & swd;                      // 今回，新たに押されたSW
  sw0 = sw;
  sw1 = swd;
  return sw2;
}

int swToNum(int sw) {
  int num = -1;
  if ((sw & SW6)!=0) {                              // 6 番のスイッチが押された
    num = 6;
  } else if ((sw & SW5)!=0) {                       // 5 番のスイッチが押された
    num = 5;
  } else if ((sw & SW4)!=0) {                       // 4 番のスイッチが押された
    num = 4;
  } else if ((sw & SW3)!=0) {                       // 3 番のスイッチが押された
    num = 3;
  } else if ((sw & SW2)!=0) {                       // 2 番のスイッチが押された
    num = 2;
  } else if ((sw & SW1)!=0) {                       // 1 番のスイッチが押された
    num = 1;
  }
  return num;
}

//-----------------------------------------
//プレイリスト追加する曲の"+"情報の保持
//-----------------------------------------
public void getAddIdxFromLcd() {
  addSongsIdx = getAllAddIdx();
}

//画面を表示する関数
void showScreen(int state, int cursorPos) {
    cls();
    locateXY(0, 0);
    putStr(getScreenTitle(state));

    int numItems = getScreenNumItems(state);
    char[][] menuItems = getScreenMenuItems(state);

    for (int i = 0; i < numItems; i=i+1) {
        locateXY(1, i + 1);

        if (i == cursorPos) {
            putStr("-> ");
        } else {
            putStr("   ");
        }

        putStr(menuItems[i]);
    }
    if (state == CONTRAST_STATE) {
      showLevelBar(getContrastLevel());
    }
    else if (state == VOLUME_STATE) {
      showLevelBar(getVolumeLevel());
    }
    else if (state == MUSIC_INF) {
      if (repeatMode == 1) {
        showRepeatOne();
      } else if (repeatMode == 2) {
        showRepeatAll();
      } else if (shuffleMode == 1) {
        showShuffleTrue();
      }
    }
    else if (state == PLAYLIST_ADDSONGS) {
      getAddIdxFromLcd();
      for (int i = 0; i < 6; i = i + 1) {  // 最大表示行
        int idx = i + list_upper + 1;
        if (idx >= 1 && idx <= playListAddSongsNum()) {
          if (addSongsIdx[idx-1] == 1) {
            locateXY(3, i + 1);  // (x=3, y=i+1)
            putStr("+");
          }
        }
      }
    }
  }

//-----------------------------------------
//曲一覧用のメモリ確保
//-----------------------------------------
void malloc_musiclist(int upper_idx){
  musicList = malloc(MAX_LIST * 4);
    int i = 0;
    while (i < MAX_LIST) {
      musicList[i] = malloc(NAME_LEN);
      char[] fname = mp3FilesGetName(i + upper_idx + 1);
      if (fname != null) {
        strCpy(musicList[i], fname);
      } else {
        musicList[i][0] = '\0';
      }
      i = i + 1;
    }
}

//-----------------------------------------
//曲一覧用のメモリ解放
//-----------------------------------------
void free_musiclist(){
  int i = 0;
    while (i < MAX_LIST) {
      free(musicList[i]);
      i = i + 1;
    }
    free(musicList);
}

//-----------------------------------------
//プレイリスト(list01~10)一覧用のメモリ確保
//-----------------------------------------
void malloc_playlist(int upper_idx){
  playList = malloc(MAX_LIST * 4);
    int i = 0;
    while (i < MAX_LIST) {
      playList[i] = malloc(NAME_LEN);
      char[] fname = playListGetName(i + upper_idx + 1);
      if (fname != null) {
        strCpy(playList[i], fname);
      } else {
        playList[i][0] = '\0';
      }
      i = i + 1;
    }
}

//-----------------------------------------
//プレイリスト(list01~list10)一覧用のメモリ解放
//-----------------------------------------
void free_playlist(){
  int i = 0;
    while (i < MAX_LIST) {
      free(playList[i]);
      i = i + 1;
    }
    free(playList);
}

//-----------------------------------------
//プレイリスト登録曲のメモリ確保
//-----------------------------------------
void malloc_playlist_register(int list_idx, int upper_idx){
  playList_register = malloc(MAX_LIST * 4);
    int i = 0;
    while (i < MAX_LIST) {
      playList_register[i] = malloc(NAME_LEN);
      char[] fname = playListSongsGetName(list_idx, upper_idx + i + 1);
      if (fname != null) {
        strCpy(playList_register[i], fname);
      } else {
        playList_register[i][0] = '\0';
      }
      i = i + 1;
    }
}

//-----------------------------------------
//プレイリスト登録曲のメモリ解放
//-----------------------------------------
void free_playlist_register(){
  int i = 0;
    while (i < MAX_LIST) {
      free(playList_register[i]);
      i = i + 1;
    }
    free(playList_register);
}

//-----------------------------------------
//プレイリストに追加可能な曲一覧のメモリ確保
//-----------------------------------------
void malloc_playlist_add(int list_idx){
  playList_add = malloc(MAX_LIST * 4);
    int i = 0;
    while (i < MAX_LIST) {
      playList_add[i] = malloc(NAME_LEN);
      char[] fname = playListAddSongsGetName(list_idx + i + 1);
      if (fname != null) {
        strCpy(playList_add[i], fname);
      } else {
        playList_add[i][0] = '\0';
      }
      i = i + 1;
    }
}

//-----------------------------------------
//プレイリストに追加可能な曲一覧のメモリ解放
//-----------------------------------------
void free_playlist_add(){
  int i = 0;
    while (i < MAX_LIST) {
      free(playList_add[i]);
      i = i + 1;
    }
    free(playList_add);
}

//-----------------------------------------
//シャッフル用リスト
//-----------------------------------------
void generateshuffleList(int total) {
  shuffleList = malloc(total * 2);
  for (int i = 0; i < total; i = i + 1) {
    shuffleList[i] = i + 1;
  }
  for (int i = 0; i < total - 1; i = i + 1) {
    int j = rand() % (total - i);
    int tmp = shuffleList[i];
    shuffleList[i] = shuffleList[i + j];
    shuffleList[i + j] = tmp;
  }
  shuffleIndex = 0;
}

//-----------------------------------------------------------------------------
// MP3 プレーヤのメインプロセス
//-----------------------------------------------------------------------------
// ここからプロセスの実行が始まる
public void shellMain() {
  spiResetLcd();  // sleepを使用するので
  cls();
  spiResetMp3();  //   プロセスが実行する
  mp3FilesInit();  // ファイル一覧を作る
  playListInit(); // プレイリストの一覧を作る
  initScreens();

  int state = HOME_STATE;
  int prevState = HOME_STATE;  // 前の状態を記憶
  int cursorPos = 0;
  int music_idx = 0;
  int total = 0;
  int listNum = 0; //選択されたプレイリスト番号を保持する．
  int songNum = 0;

  showScreen(state, cursorPos);

  //メインプロセスのループ
  for (;;) {
    int sw = readSw();
    int num = swToNum(sw);
    int filenum = mp3FilesGetTotalNum(); //MP3ファイルの総数

    if (num == 1) {  // SW1 = 上
      int numItems = getScreenNumItems(state);

      // カーソルがまだ上に動かせる
      if (cursorPos > 0) {
        cursorPos = cursorPos - 1;
      } else if (state == MUSIC_STATE) {
        //曲選択画面で，かつ上端まで来たときの処理
        if (cursorPos == 0 && list_upper > 0) {
          list_upper = list_upper - 1;
          free_musiclist();
          malloc_musiclist(list_upper);
          setScreenMenuItems(state, musicList, MAX_LIST);
        }
      } else if (state == PLAYLIST_STATE){
        //プレイリスト画面で，かつ上端まで来たときの処理
        if (cursorPos == 0 && list_upper > 0) {
          list_upper = list_upper - 1;
          free_playlist();
          malloc_playlist(list_upper);
          setScreenMenuItems(state, playList, MAX_LIST);
        }
      } else if (state == PLAYLIST_SONGS && playListSongsGetNum(listNum) > 6) {
        //プレイリスト登録曲一覧画面で，かつカーソルが上端まできたときの処理
        if (cursorPos == 0 && list_upper > 0) {
          list_upper = list_upper - 1;
          free_playlist_register();
          malloc_playlist_register(listNum, list_upper);
          setScreenMenuItems(state, playList_register, MAX_LIST);
        }
      }else if (state == PLAYLIST_ADDSONGS && playListAddSongsNum() > 6) {
        //プレイリストの曲追加画面で，かつ上端まで来たときの処理
        if (cursorPos == 0 && list_upper > 0) {
          list_upper = list_upper - 1;
          free_playlist_add();
          malloc_playlist_add(list_upper);
          setScreenMenuItems(state, playList_add, MAX_LIST);
        }
      } else {
        // 項目数が6以下のとき：ループ処理
        cursorPos = numItems - 1;
        }
        prevcursor[state] = cursorPos; //カーソル情報の保持
        prevupper[state] = list_upper;
        showScreen(state, cursorPos);
    }
    else if (num == 5) {  // SW5 = 下
      int numItems = getScreenNumItems(state);

      // カーソルがまだ下に動かせる
      if (cursorPos + 1 < numItems) {
        cursorPos = cursorPos + 1;
      } else if (state == MUSIC_STATE) {
        //曲選択画面で，かつ下端まで来たときの処理
        if (cursorPos + list_upper < filenum - 1) {
          list_upper = list_upper + 1;
          free_musiclist();
          malloc_musiclist(list_upper);
          setScreenMenuItems(state, musicList, MAX_LIST);
        }
      } else if (state == PLAYLIST_STATE) {
        //プレイリスト画面で，かつ下端まで来たときのスクロール処理
        if (cursorPos + list_upper < 9) {
          list_upper = list_upper + 1;
          free_playlist();
          malloc_playlist(list_upper);
          setScreenMenuItems(state, playList, MAX_LIST);
        }
      } else if (state == PLAYLIST_SONGS && playListSongsGetNum(listNum) > 6) {
        //プレイリストの曲一覧画面で，かつカーソルが下端まで来たときのスクロール処理
        if (cursorPos + list_upper < playListSongsGetNum(listNum) - 1) {
          list_upper = list_upper + 1;
          free_playlist_register();
          malloc_playlist_register(listNum, list_upper);
          setScreenMenuItems(state, playList_register, MAX_LIST);
        }
      } else if (state == PLAYLIST_ADDSONGS && playListAddSongsNum() > 6) {
        //曲追加画面で，かつカーソルが下端まで来たときのスクロール処理
        if (cursorPos + list_upper < playListAddSongsNum() - 1) {
          list_upper = list_upper + 1;
          free_playlist_add();
          malloc_playlist_add(list_upper);
          setScreenMenuItems(state, playList_add, MAX_LIST);
        }
      }
      else {
        //下端→上端ループ
        cursorPos = 0;
        list_upper = 0;
      }
      prevcursor[state] = cursorPos;
      prevupper[state] = list_upper;
      showScreen(state, cursorPos);
    }

    else if (num == 3) { // SW3 = 決定
      if (state == HOME_STATE) {
        //musicを押した場合
        if (cursorPos + 1 == 1) {
          mp3FilesInit();                                         // playList で格納した fnames の影響を解消するため
          malloc_musiclist(list_upper);
          setScreenMenuItems(MUSIC_STATE, musicList, MAX_LIST);
          prevState = state;
          state = MUSIC_STATE;
          cursorPos = 0;
          showScreen(state, cursorPos);
        } else {
          //PlayListを押した場合
          cursorPos=0;
          list_upper = 0;
          prevState = state;
          state = PLAYLIST_STATE;
          int numlist = getScreenNumItems(state);
          malloc_playlist(list_upper);
          setScreenMenuItems(state, playList, numlist);
          showScreen(state, cursorPos);
        }
      }
      else if (state == MUSIC_STATE) {
        char[] selectedTitle = malloc(NAME_LEN);
        music_idx = cursorPos + list_upper +1;
        char[] fname = mp3FilesGetName(music_idx);
        
        if (fname != null) {
          strCpy(selectedTitle, fname);
          setScreenTitle(MUSIC_INF, selectedTitle);
          prevState = state;
          state = MUSIC_INF;
          cursorPos = 0;
          showScreen(state, cursorPos);
        }
      }
      else if (state == MUSIC_INF) {
        if (cursorPos == 0) {  // PLAY 選択
          char[] path = mp3FilesGetPath(music_idx);  // 曲パス取得
          if (path != null) {
            play(path);
            isPlayRequested = 1;
          }
        }
        else if (cursorPos == 1) {  // PAUSE 選択
          stop();
          isPlayRequested = 0;
        }
        else if (cursorPos == 2) { //NEXT選択時
        int status = playing_status();
          stop();
          total = mp3FilesGetTotalNum();
          if (repeatMode != 1) {
            music_idx = (music_idx % total) + 1;
          }
          char[] nextTitle = mp3FilesGetName(music_idx);
          if (nextTitle != null) {
            setScreenTitle(MUSIC_INF, nextTitle);
            showScreen(state, cursorPos);
            char[] path = mp3FilesGetPath(music_idx);
            if (status == 1) {
              play(path);
            }
          }
        }
        else if (cursorPos == 3) {  // PREV 選択
          int status = playing_status();
          stop();
          total = mp3FilesGetTotalNum();
          if (repeatMode != 1){
            music_idx = (music_idx + total - 2) % total + 1;
          }
          char[] prevTitle = mp3FilesGetName(music_idx);
          if (prevTitle != null) {
            setScreenTitle(MUSIC_INF, prevTitle);
            showScreen(state, cursorPos);
            char[] path = mp3FilesGetPath(music_idx);
            if (status == 1) {
              play(path);
            }
          }
        }
        else if (cursorPos == 4) { //REPEAT選択
          repeatMode = (repeatMode + 1) % 3;
          showRepeatClear();

          if (repeatMode > 0) { //リピート時シャッフルは無効化
            shuffleMode = 0;
            showShuffleClear();
          }

          if (repeatMode == 1) {
            showRepeatOne();
          }else if (repeatMode == 2) {
            showRepeatAll();
          }
        }
        else if (cursorPos == 5) { //SHUFLE選択
          if(shuffleMode == 0) {
            shuffleMode = 1;
            showShuffleTrue();
            generateshuffleList(mp3FilesGetTotalNum());
            shuffleIndex = 0;

            repeatMode = 0; //シャッフル時リピートは無効化
            showRepeatClear();
          }else {
            shuffleMode = 0;
            showShuffleClear();
          }
        }
      }
      else if (state == OPTION_STATE) {
        if (cursorPos == 0) {  // VOLUME
          state = VOLUME_STATE;
          cursorPos = 0;
          showScreen(state, cursorPos);
        }
        else if (cursorPos == 1) {  // CONTRAST
          state = CONTRAST_STATE;
          cursorPos = 0;
          showScreen(state, cursorPos);
        }
      }
      else if (state == VOLUME_STATE) {
        if (cursorPos == 0) {
          updateVolume(cursorPos);
          showScreen(state, cursorPos);
        } else if (cursorPos == 1) {
          updateVolume(cursorPos);
          showScreen(state, cursorPos);
        }
      }
      else if (state == CONTRAST_STATE) {
        if (cursorPos == 0) {  // UP
          updateContrast(cursorPos);
          showScreen(state, cursorPos);
        } else if (cursorPos == 1) {  // DOWN
          updateContrast(cursorPos);
          showScreen(state, cursorPos);
        }
      }
      else if (state == PLAYLIST_STATE) {
        mp3FilesInit();                                       // 戻るボタンを押したときに発生するバグの解消
        listNum = cursorPos +  list_upper + 1;
        showPlayListSongs(listNum);
        if (playListSongsGetNum(listNum) <= MAX_LIST) {
          songNum = playListSongsGetNum(listNum);
        } else {
          songNum = MAX_LIST;
        }
        list_upper = 0;
        malloc_playlist_register(listNum, list_upper);
        prevState = state;
        state = PLAYLIST_SONGS;
        setScreenMenuItems(state, playList_register, songNum);
        cursorPos = 0;
        showScreen(state, cursorPos);
      }
      else if (state == PLAYLIST_SONGS) {
        char[] fname = playListSongsGetName(listNum, cursorPos + list_upper + 1);
        if (fname != null && strCmp(fname, "+") == 0) {
          // いまのカーソル位置（cursorPos + list_upper）が "+"なら曲を追加する
          mp3FilesInit();                                       
          playListAddSongs(listNum); // 追加可能な曲のリストを作成する
          if (playListAddSongsNum() <= MAX_LIST) {
            songNum = playListAddSongsNum();
          } else {
            songNum = MAX_LIST;
          }
          list_upper = 0;
          malloc_playlist_add(list_upper);
          prevState = state;
          state = PLAYLIST_ADDSONGS;
          setScreenMenuItems(state, playList_add, songNum);
          cursorPos = 0;
          addIdxInit();
          showScreen(state, cursorPos);
        }
        else {
          // 選択された曲を再生する
          mp3FilesSetToFnames(playListSongsNametoMp3Files()); //mp3Files の fnames にプレイリストの曲を格納する
          char[] selectedTitle = malloc(NAME_LEN);
          music_idx = cursorPos + list_upper + 1;
          
          if (fname != null) {
            strCpy(selectedTitle, fname);
            setScreenTitle(MUSIC_INF, selectedTitle);
            prevState = state;
            state = MUSIC_INF;
            list_upper = 0;
            cursorPos = 0;
            showScreen(state, cursorPos);
          }
        }
      }
      else if (state == PLAYLIST_ADDSONGS) {
        int idx = cursorPos + list_upper + 1;
        if (getAddIdx(idx) == 0) {
          showAddSongs(cursorPos, idx);
        } else {
          showAddSongsClear(cursorPos, idx);
        }
      }
    }

    else if (num == 2) { // SW2 = 戻る
      if (state == MUSIC_STATE) {
        free_musiclist();
        state = HOME_STATE;
        cursorPos = prevcursor[state];
        list_upper = prevupper[state];
        showScreen(state, cursorPos);
      }
      else if (state == MUSIC_INF) {
        if (prevState == MUSIC_STATE) {
          state = MUSIC_STATE;
        } else {
          state = PLAYLIST_SONGS;
        }
        cursorPos = prevcursor[state];
        list_upper = prevupper[state];
        showScreen(state, cursorPos);
      }
      else if (state == VOLUME_STATE) {
        state = OPTION_STATE;
        cursorPos = prevcursor[state];
        list_upper = prevupper[state];
        showScreen(state, cursorPos);
      }
      else if (state == CONTRAST_STATE) {
        state = OPTION_STATE;
        cursorPos = prevcursor[state];
        list_upper = prevupper[state];
        showScreen(state, cursorPos);
      }
      else if (state == PLAYLIST_STATE) {
        free_playlist();
        state = HOME_STATE;
        cursorPos = prevcursor[state];
        list_upper = prevupper[state];
        showScreen(state, cursorPos);
      }
      else if (state == PLAYLIST_SONGS) {
        free_playlist_register();
        state = PLAYLIST_STATE;
        cursorPos = prevcursor[state];
        list_upper = prevupper[state];
        showScreen(state, cursorPos);
      }
      else if (state == PLAYLIST_ADDSONGS) {
        playListRegisterSongs(listNum, addSongsIdx);
        free_playlist_add();
        state = PLAYLIST_SONGS;
        cursorPos = prevcursor[state];
        list_upper = prevupper[state];
        free_playlist_register();
        showPlayListSongs(listNum);
        malloc_playlist_register(listNum, list_upper); // プレイリスト追加の変更反映
        if (playListSongsGetNum(listNum) <= MAX_LIST) {
          songNum = playListSongsGetNum(listNum);
        } else {
          songNum = MAX_LIST;
        }
        setScreenMenuItems(state, playList_register, songNum);
        showScreen(state, cursorPos);
      }
    }

    else if (num == 6) { // SW6 = OPTION 画面の出入り
      if (state == VOLUME_STATE || state == CONTRAST_STATE) {
        state = prevState;
        cursorPos = prevcursor[state];
        list_upper = prevupper[state];
        showScreen(state, cursorPos);
      }
      else if (state == OPTION_STATE) {
        state = prevState;      // OPTIONに入る前の状態を記録
        cursorPos = prevcursor[state];
        list_upper = prevupper[state];
        showScreen(state, cursorPos); 
      } else { //OPTION画面に入る．
        prevState = state;
        state = OPTION_STATE;
        cursorPos = 0;
        showScreen(state, cursorPos);
      }
    }

    if (playing_status() == 0 && isPlayRequested == 1) { //リピートとシャッフル再生
      if (shuffleMode == 1) { //シャッフル再生
        total = mp3FilesGetTotalNum();
        if (shuffleIndex < total) {
          music_idx = shuffleList[shuffleIndex];
          shuffleIndex = shuffleIndex + 1;
          char[] title = mp3FilesGetName(music_idx);
          if (title != null) {
            setScreenTitle(MUSIC_INF, title);
            showScreen(state, cursorPos);
            char[] path = mp3FilesGetPath(music_idx);
            play(path);
            isPlayRequested = 1;
          }
        } else {  //再生する曲がなくなったら
          shuffleMode = 0;
          isPlayRequested = 0;
          showShuffleClear();
        }
      } else {
        if (repeatMode == 0) { //通常再生
          total = mp3FilesGetTotalNum();
          if (music_idx >= total) {
            isPlayRequested = 0;
          } else {
            music_idx = (music_idx % total) + 1;
            char[] nextTitle = mp3FilesGetName(music_idx);
            if (nextTitle != null) {
              setScreenTitle(MUSIC_INF, nextTitle);
              showScreen(state, cursorPos);
              char[] path = mp3FilesGetPath(music_idx);
              play(path);
              isPlayRequested = 1;
            }
          }
        }
        else if (repeatMode == 1 || repeatMode == 2) {  //リピート再生
          if (repeatMode == 2) {  //リピートALL
            total = mp3FilesGetTotalNum();
            music_idx = (music_idx % total) + 1;
          }
          char[] autoTitle = mp3FilesGetName(music_idx);
          if (autoTitle != null) {
            setScreenTitle(MUSIC_INF, autoTitle);
            showScreen(state, cursorPos);
            char[] path = mp3FilesGetPath(music_idx);
            play(path);
            isPlayRequested = 1;
          }
        }
      }
    }
    sleep(10);  // 負荷軽減，10ms待つ
  }
}
