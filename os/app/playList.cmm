/*
 * TacOS Source Code
 *    Tokuyama kousen Advanced educational Computer.
 *
 * Copyright (C) 2020 by
 *                      Dept. of Computer Science and Electronic Engineering,
 *                      Tokuyama College of Technology, JAPAN
 *
 *   上記著作権者は，Free Software Foundation によって公開されている GNU 一般公
 * 衆利用許諾契約書バージョン２に記述されている条件を満たす場合に限り，本ソース
 * コード(本ソースコードを改変したものを含む．以下同様)を使用・複製・改変・再配
 * 布することを無償で許諾する．
 *
 *   本ソースコードは＊全くの無保証＊で提供されるものである。上記著作権者および
 * 関連機関・個人は本ソースコードに関して，その適用可能性も含めて，いかなる保証
 * も行わない．また，本ソースコードの利用により直接的または間接的に生じたいかな
 * る損害に関しても，その責任を負わない．
 *
 * This programming code was procuded by CE2.
 */

#include "playList.hmm"
#include "mp3Files.hmm"
#include <fs.hmm>
#include <util.hmm>
#include "appUtil.hmm"
#include "mm.hmm"

#define LIST_NUM 10 //プレイリストは10個で固定する
#define MAX_LIST 50

char[][] playList = array(50, 13);                   // 1つのプレイリストに登録できる最大曲数は仮に50曲
char[][] mp3Files = array(50, 13);
char[][] canAddSongs = array(50, 13);
char[][] sortSongs = array(99, 13);                  // プレイリスト内の曲順ソートのための配列確保

char[][] fnames = array(10, 13);                     // 12345678.123
char[] addName = array(13);                          // 8.3 形式に従う

char[] playlistDir = "/playlist";
char[] path = array(18);                            // /playlist/12345678.123
char[] list_path = array(18); 
char[] ch_buf = array(2);                           // ファイルから読み込む1文字＋終端記号
int[] line_num = array(LIST_NUM);                  // プレイリストの登録されている曲数を保持する配列
int addNum = 0;
int nowIdx = 0;
int sortIdx = 0;

char[] fnameToPath(char[] fname) {
  strCpy(path, playlistDir);
  strCat(path, "/");
  strCat(path, fname);
  return path;
}

// プレイリストの一覧を表示する．
public void playListInit() {
  int fd;                                           // ファイルディスクリプタ
  if ((fd=open(playlistDir, READ_MODE))<0) {
    panic("panic:can't open playList Dir");
  }
  Dir dir;
  int i = 0;
  while (i< LIST_NUM && (dir=readDir(fd, "TXT"))!=null) {   // 最大10つファイル名を読む
    strCpy(fnames[i], dir.name);
    i = i + 1;
  }
  close(fd);
  //リスト番号を整理して01→10で並び替える，単純なバブルソート
  int p = 0;
  int q = LIST_NUM - 1;
  while (p < LIST_NUM) {
    q = LIST_NUM - 1; //qの初期化 
    while (q > p) {
        if (strCmp(fnames[q - 1], fnames[q]) > 0) {
            char [] tmp =  malloc(13); //ソートのための一時待避所
            strCpy(tmp, fnames[q - 1]);
            strCpy(fnames[q - 1], fnames[q]);
            strCpy(fnames[q], tmp);
            free(tmp);
        }
        q =  q - 1; // 比較要素の更新
    }
    p = p + 1; //確定要素の更新
  }
}

// n 番目ファイル名を返す（1<=n && n<=LIST_NUM）
public char[] playListGetName(int n) {
  if (1<=n && n<=LIST_NUM) {
    //リストは".txt"を消して表示させる．
    char[] list_fnames = malloc(13);     // 表示用バッファの確保
    strCpy(list_fnames, fnames[n - 1]);  // list_fname に fnames[n - 1] をコピーする
    //拡張子"."が来るまで読み込む
    int idx = 0;
    while(list_fnames[idx] != '.' && list_fnames[idx] != '\0') {
        idx = idx + 1;
    }
    list_fnames[idx] = '\0'; 
    return list_fnames;
  }
  return null;
}

// n 番目パス名を返す（1<=n && n<=LIST_NUM）
public char[] playListGetPath(int n) {
  if (1<=n && n<=LIST_NUM) {
    return fnameToPath(fnames[n-1]);
  }
  return null;
}

// n番目のLISTnに登録されている曲の一覧を取得
public void showPlayListSongs(int n, boolean isPlus) {  // 第二引数：リストに "+" を含めるかどうか．true なら含めて，false なら除外する

  //プレイリストの初期化処理
  for (int i = 0; i < MAX_LIST; i = i+1) {
    playList[i][0] = '\0';
  }

  strCpy(list_path, playlistDir);
  strCat(list_path, "/");
  strCat(list_path, fnames[n-1]);

  //ファイルをオープンする．
  int fp = open(list_path, READ_MODE);
  if (fp < 0) {
    panic("panic : can't open list file. The error occurred.");
  }
  int m = 0;
  while (read(fp, ch_buf, 1) != 0) {
    ch_buf[1] = '\0';
    if (ch_buf[0] == 0x0a) {
      playList[m][strLen(playList[m])] = '\0';      // 行の最後に終端記号を入れる．
      m = m + 1;
    } else {
        strCat(playList[m], ch_buf);                // １文字ずつ文字列を連結する．
    }
  }
  if (playList[m][0] == '\0') {
    line_num[n-1] = m;
  } else {
    playList[m][strLen(playList[m])] = '\0';       // 最後に終端記号を入れる．
    line_num[n-1] = m + 1;                         // プレイリストに登録されている曲数を代入する．
  }
  if (line_num[n-1] != mp3FilesGetTotalNum() && line_num[n-1] < MAX_LIST && isPlus){     // プレイリストに登録されている曲数がMP3フォルダ直下にある曲数と等しくなければ "+" アイコンを追加
    strCat(playList[line_num[n-1]],"+");
    line_num[n-1] = line_num[n-1] + 1;
  }
  close(fp);
}                              


//--------------------!!CAUTION!!-----------------------
// 必ず showPlayListSongs(int n, boolean isPlus) を実行してから取得すること！
//--------------------!!CAUTION!!-----------------------
// LISTn に登録されている曲数を返す（'+'も含む要素数である．）
public int playListSongsGetNum(int n) {
  return line_num[n-1];
}

//--------------------!!CAUTION!!-----------------------
// 必ず showPlayListSongs(int n, boolean isPlus) を実行してから取得すること！
//--------------------!!CAUTION!!-----------------------
// m 番目のリスト内の n 番目ファイル名を返す（1<=n && n<=line_num[n-1]）
public char[] playListSongsGetName(int m, int n) {
  if (1<=n && n<=line_num[m-1]) {
    return playList[n-1];
  }
  return null;
}

//--------------------!!CAUTION!!-----------------------
// 必ず showPlayListSongs(int n, boolean isPlus) を実行してから取得すること！
//--------------------!!CAUTION!!-----------------------
// 選択中プレイリスト内の全リストを返す．mp3Files.cmm に渡す配列用の取得関数
public char[][] playListSongsNametoMp3Files() {
  return playList;
}

// 選択中プレイリストに新たに曲を追加する
public void playListAddSongs(int n) {
  // mp3Filesの fnames と一致するファイル名は新規追加曲に含まない
  mp3Files = mp3FilesGetAllName();    //上書きしないのでポインタにアクセスする

  //追加リストの初期化処理
  for (int i = 0; i < MAX_LIST; i = i+1) {
    canAddSongs[i][0] = '\0';
  }

  addNum = 0;
  boolean canAdd;
  for (int p = 0; p < mp3FilesGetTotalNum(); p = p + 1) {
    canAdd = true;
    for (int q = 0; q < line_num[n-1]; q = q + 1 ) {
      if (strCmp(playList[q], "+") != 0 && strCmp(playList[q], mp3Files[p]) == 0) {
        canAdd = false;
      }
    }
    if (canAdd && addNum < MAX_LIST) {
      strCpy(canAddSongs[addNum], mp3Files[p]);
      addNum = addNum + 1;
    }
  }
}

//--------------------!!CAUTION!!-----------------------
// 必ずplayListAddSongs(int n) を実行してから取得すること！
//--------------------!!CAUTION!!-----------------------
// 追加できる曲の総数を返す
public int playListAddSongsNum() {
  return addNum;
}

//--------------------!!CAUTION!!-----------------------
// 必ず playListAddSongs(int n) を実行してから取得すること！
//--------------------!!CAUTION!!-----------------------
// n 番目ファイル名を返す（1<=n && n<=playListAddSongsNum()）
public char[] playListAddSongsGetName(int n) {
  if (1<=n && n<=playListAddSongsNum()) {
    return canAddSongs[n-1];
  }
  return null;
}

// プレイリストファイルに新たな曲を末尾に登録する．
public void playListRegisterSongs(int l, int[] addSongs) {

  list_path[0] = '\0';             // パスの初期化
  strCpy(list_path, playlistDir);
  strCat(list_path, "/");
  strCat(list_path, fnames[l-1]);
  
  // 一旦 read モードで fp を EOF まで移動させる
  int fp = open(list_path, READ_MODE);
  if (fp < 0) {
    panic("panic : can't open list file READ_MODE. The error occurred.");
  }

  int len = 0;
  char[] buf = malloc(1);
  while (read(fp, buf, 1) > 0) {
    len = len + 1;
  }
  free(buf);
  close(fp);

  // 追記モードでファイルを開き，EOF までのバイト数 len だけ fp を seek させる
  fp = open(list_path, APPEND_MODE);
  if (fp < 0) {
    panic("panic : can't reopen list file in APPEND_MODE.");
  }
  seek(fp, 0, len);                            // fp を seek させる
  for (int m = 0; m < playListAddSongsNum(); m = m + 1) {
    nowIdx = 0;
    if (addSongs[m] == 1) {
      addName = playListAddSongsGetName(m + 1); // 追加するファイル名を格納する
      while (addName[nowIdx] != '\0') {
        ch_buf[0] = addName[nowIdx];
        ch_buf[1] = '\0';
        if (write(fp, ch_buf, 1) < 0) {
          panic("Error occurred. File write was not finished.\n");
        }
      nowIdx = nowIdx + 1;
      }
      ch_buf[0] = '\n';
      if (write(fp, ch_buf, 1) < 0) {
          panic("Error occurred. File write was not finished.\n");
      }
    }
  }
  ch_buf[0] = '\0';
  if (write(fp, ch_buf, 1) < 0) {
      panic("Error occurred. File write was not finished.\n");
  }
  close(fp);
}

// プレイリスト登録曲の削除
public void playListDeleteSongs(int a, int[] delSongs) {

  list_path[0] = '\0';             // パスの初期化
  strCpy(list_path, playlistDir);
  strCat(list_path, "/");
  strCat(list_path, fnames[a-1]);

  int dp = remove(list_path);  // 一旦ファイルを消す
  if (dp < 0) {
    panic("panic : can't remove file.");
  }

  int cp = creat(list_path);   // 空のファイルを作成
  if (cp < 0) {
    panic("panic : can't creat file.");
  }

  // delSongs と playlist の中身を照らし合わせて WRITE_MODE で上書きすることで削除を再現する
  int fp = open(list_path, WRITE_MODE);
  if (fp < 0) {
    panic("panic : can't reopen list file in WRITE_MODE.");
  }
  for (int i = 0; i < line_num[a-1]; i = i + 1) {
    nowIdx = 0;
    if (delSongs[i] == 0) {
      while (playList[i][nowIdx] != '\0') {
        ch_buf[0] = playList[i][nowIdx];
        ch_buf[1] = '\0';
        if (write(fp, ch_buf, 1) < 0) {
          panic("Error occurred. File write was not finished.\n");
        }
        nowIdx = nowIdx + 1;
      }
      ch_buf[0] = '\n';
      if (write(fp, ch_buf, 1) < 0) {
          panic("Error occurred. File write was not finished.\n");
      }
    }
  }
  ch_buf[0] = '\0';
  if (write(fp, ch_buf, 1) < 0) {
      panic("Error occurred. File write was not finished.\n");
  }
  close(fp);
}

//----------------------------------------
// プレイリストに登録されている曲の順序変更
//----------------------------------------
// n 番目の曲を移動させる
public void playListSortSongs(int m, int n) {
  
  sortIdx = n-1;
  char[] insert;
  // 曲順ソートのための配列をクリア
  for(int i = 0; i < 99; i = i + 1) {
    sortSongs[i][0] = '\0';
  }

  // 曲順ソートのための配列の作成．もとの曲インデクスn に対して 2 * n + 1 に格納してあげればよい．
  int regist_idx = 0;
  for(int i = 0; i <  playListSongsGetNum(m); i = i + 1) {
    if (i == n-1) {
      insert = " ** Now ** ";
      strCpy(sortSongs[2*i], insert);
    } else {
      insert = "  * Ins *  ";
      strCpy(sortSongs[2*i], insert);
    }
    if (i != playListSongsGetNum(m)-1) {
      if (i == n-1) {
        regist_idx = regist_idx + 1;
      }
      strCpy(sortSongs[2*i+1], playList[regist_idx]);
    }
    regist_idx = regist_idx + 1;
  }
}

//--------------------!!CAUTION!!-----------------------
// 必ず playListSortSongs(int n) を実行してから取得すること！
//--------------------!!CAUTION!!-----------------------
// ソート用配列の n 番目の要素を返す
public char[] playListSortSongsGetName(int n) {
  return sortSongs[n-1];
}

//--------------------!!CAUTION!!-----------------------
// 必ず playListAddSongs(int n) を実行してから取得すること！
//--------------------!!CAUTION!!-----------------------
// n = cursorPos + list_upper + 1 で指定された位置に曲を移動させてファイルに書き込む．削除ではないので，別段ファイルを作成し直さなくてよい．
public void playListSortSongsInsert(int m, int n) {

  list_path[0] = '\0';             // パスの初期化
  strCpy(list_path, playlistDir);
  strCat(list_path, "/");
  strCat(list_path, fnames[m-1]);

  int fp = open(list_path, WRITE_MODE);
  if (fp < 0) {
    panic("panic : can't reopen list file in WRITE_MODE.");
  }

  for (int i = 0; i < 2 * playListSongsGetNum(m) - 1; i = i + 1) {
    nowIdx = 0;
    if(i == n-1) {                          // ソート先のインデクスかどうか
      while(playList[sortIdx][nowIdx] != '\0') {
        ch_buf[0] = playList[sortIdx][nowIdx];
        ch_buf[1] = '\0';
        if (write(fp, ch_buf, 1) < 0) {
          panic("Error occurred. File write was not finished.\n");
        }
        nowIdx = nowIdx + 1;
      }
      ch_buf[0] = '\n';
      if (write(fp, ch_buf, 1) < 0) {
          panic("Error occurred. File write was not finished.\n");
      }
    } else if (i % 2 == 1) {
      nowIdx = 0;
      while(sortSongs[i][nowIdx] != '\0' && sortSongs[i][0] != '\0') {
        ch_buf[0] = sortSongs[i][nowIdx];
        ch_buf[1] = '\0';
        if (write(fp, ch_buf, 1) < 0) {
          panic("Error occurred. File write was not finished.\n");
        }
        nowIdx = nowIdx + 1;
      }
      ch_buf[0] = '\n';
      if (write(fp, ch_buf, 1) < 0) {
          panic("Error occurred. File write was not finished.\n");
      }
    }
  }
  ch_buf[0] = '\0';
  if (write(fp, ch_buf, 1) < 0) {
      panic("Error occurred. File write was not finished.\n");
  }
  close(fp);
}