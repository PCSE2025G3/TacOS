/*
 * TacOS Source Code
 *    Tokuyama kousen Advanced educational Computer.
 *
 * Copyright (C) 2020 by
 *                      Dept. of Computer Science and Electronic Engineering,
 *                      Tokuyama College of Technology, JAPAN
 *
 *   上記著作権者は，Free Software Foundation によって公開されている GNU 一般公
 * 衆利用許諾契約書バージョン２に記述されている条件を満たす場合に限り，本ソース
 * コード(本ソースコードを改変したものを含む．以下同様)を使用・複製・改変・再配
 * 布することを無償で許諾する．
 *
 *   本ソースコードは＊全くの無保証＊で提供されるものである。上記著作権者および
 * 関連機関・個人は本ソースコードに関して，その適用可能性も含めて，いかなる保証
 * も行わない．また，本ソースコードの利用により直接的または間接的に生じたいかな
 * る損害に関しても，その責任を負わない．
 *
 *
 */

/*
 * timerProc.cmm : 時間計測のメインプロセス
 *
 * 2025.07.24 : 新規作成
 *
 * $Id$
 *
 */

#include <kernel.hmm> //使用するヘッダー宣言
#include <util.hmm>
#include "appUtil.hmm"
#include "spi.hmm"
#include "lcd.hmm"
#include "mp3Proc.hmm"

// メッセージ
#define TIMER_STOP 1
#define TIMER_START 2

// 画面の番号定義
#define MUSIC_INF 2

// レスポンス
#define OK 0
#define ERR 1

// モード定義
#define TIMER_MODE_SLEEP    1
#define TIMER_MODE_PLAYBACK 2

int link;                                   // メッセージ通信用のリンク
boolean syncFlag = false;                   // クライアントが同期待ちである
boolean showFlag = true;
int timer_sec = 0;
int timer_msec = 0;
int timer_offset = 0;
int timerState = 0;
int timerMode = 0;

//-------------------------------------
// クライアント（ShellProc）が呼び出す
//-------------------------------------

// タイマーカウント停止
public void timerStop() {
  syncFlag = true;                          // コマンド待ちにする
  timerState = 0;
  timerMode = 0;
  sndrec(link, TIMER_STOP, 0, 0, 0);           // 同期要求メッセージを送る
}

// タイマーカウントスタート
public void timerStart(int mode) {
  timerMode  = mode;
  syncFlag = false;
  timerState = 1;
  sndrec(link, TIMER_START, 0, 0, 0);
}

void countTimer() {
  send(link,OK);                            // クライアントに成功を通知
  timer_sec = 0;
  timer_msec = 0;
  if (timerMode == TIMER_MODE_PLAYBACK) {
    // MP3 再生タイマー
    spiWriteMp3Reg(0x04, 0x00);
    spiWriteMp3Reg(0x04, 0x00); 
    while (true) {
      sleep(200);
      timer_sec = spiReadMp3Reg(0x4);  // 秒数を読み取り
      if (syncFlag) break;
    }

  } else if (timerMode == TIMER_MODE_SLEEP) {
    // 無音タイマー
    while (true) {
      sleep(90);
      int i = 0;
      for (int n = 0; n < 12680; n = n + 1) {
        i = i + n;
      }
      timer_msec = timer_msec + 100;
      if (timer_msec >= 1000) {
        timer_sec = timer_sec + 1;
        timer_msec = 0;
      }
      if (syncFlag) break;
    }
  }
}

public void timerMain() {
  spiResetLcd();                            // sleepを使用するので
  link = newLink();                         // クライアント待受用のリンク
  for(;;) {
    Link l=receive(link);                   // クライアントから受信待ち
    if (l.op==TIMER_START) {                // カウント開始のメッセージかどうか
      countTimer();
    } 
    else if (l.op==TIMER_STOP) {
      send(link,OK);
    }
  }
}

// タイマーのカウント秒数を返す．描画は shellProc に任せる
public int getTimerSec() {
  return timer_sec;
}

// タイマーの起動状態を返す．
public int getTimerStatus() {
  return timerState;
}

public int getTimerMode() {
  return timerMode;
}